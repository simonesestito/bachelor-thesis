\chapter{Analisi dinamica}
Per analisi dinamica di un malware si intende lo studio di tutti i suoi comportamenti durante l'esecuzione in un ambiente controllato, come una sandbox.
Comportamenti sospetti possono essere la modifica di particolari chiavi di registri, la sovrascrittura di file privati dell'utente che non dovrebbe manipolare, la ricerca di file con nomi che potrebbero nascondere contenuti sensibili (ad esempio legge tutti i file che contengono la parola  "password" nel nome, come \texttt{password.txt}) o altre situazioni ancora.

Lo scopo di ciò che verrà realizzato in questa fase del progetto è di analizzare automaticamente l'esecuzione di un malware, così da riportare tutti gli elementi degni di nota all'analista o al servizio di Threat Intelligence in un formato machine-readable come JSON.
Le operazioni svolte in questa fase sono indipendenti dalla componente statica appena vista:
infatti, l'obiettivo sarà di lasciare la decisione all'analista o alla Threat Intelligence automatica sulla base di una confidence del risultato finale (se malevolo o meno), per eseguire questo processo solo nei casi di reale utilità, siccome sarà molto più esoso di risorse, quindi avente un maggior costo economico.

L'analizzatore dinamico, comprensivo della sandbox e di tutto ciò che è descritto in questo capitolo, è stato sviluppato ed eseguito in locale. Tuttavia, è già stato predisposto per un futuro impiego su un server gestito dall'azienda dove possa eseguire e ricevere task attraverso una REST API o altro interfacciamento.
Come nell'analizzatore statico, ritroviamo anche qui tutte le caratteristiche di qualità come la massima flessibilità ed estensibilità con altri strumenti nel corso della sua evoluzione.

L'esecuzione del possibile malware deve avvenire necessariamente in un ambiente isolato e supervisionato, idealmente riducendo a zero le possibilità che possa evadere e infettare il sistema host.
Non potrà mai esistere un sistema che, in maniera assoluta, permetta l'esecuzione di un programma senza rischi, potendo esistere vulnerabilità zero-day in tutte le componenti coinvolte, senza imporre limitazioni che inficerebbero sull'esito dell'analisi stessa, come disconnettere fisicamente un host reale da tutte le interfacce di rete e distruggere l'ambiente completamente al termine.
Un software predisposto per fare ciò prende il nome di \emph{Sandbox}.

\section{Cuckoo Sandbox}
Per la realizzazione del progetto è stato adottato \emph{Cuckoo Sandbox}.
\footnote{\url{https://github.com/cuckoosandbox/cuckoo}}
Si tratta di un progetto open-source, rilasciato sotto licenza GPLv3 dalla Cuckoo Foundation, leader del settore che fornisce la base su cui lavorare e fare tutte le dovute modifiche del caso.
Consente di venire a conoscenza dell'esatto comportamento avuto dal malware durante la sua esecuzione, includendo la lista completa delle chiamate di sistema di ogni processo, nonché la cattura del traffico di rete, screenshot della UI durante l'esecuzione e il contenuto dei file creati nel sistema.

Viene fornito di due componenti: l'\emph{Host} e uno o più \emph{Guest}.
L'Host, anche chiamato Orchestrator, ha il compito di gestire i Guest, come avviarli, interromperli, analizzare il traffico di rete intercettato e tutta l'interpretazione dei risultati raw ottenuti dal Guest, così da ottenere il report.
Un Guest è tipicamente una VM, ma può essere anche un host fisico distinto, che contiene il sistema operativo, tutti i software che ci aspetteremmo in un PC tradizionale che vogliamo simulare, insieme all'Agent di Cuckoo, che comunicherà con l'Orchestrator per coordinare il lavoro e riportare i risultati.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{assets/cuckoo_default_architecture.png}
    \caption{Architettura di Host e Guest di Cuckoo così come viene fornito \\ Crediti: cuckoo.readthedocs.io}
    \label{fig:cuckoo_default_architecture}
\end{figure}

Su questa base, sono state fatte numerose lavorazioni illustrate nelle sezioni successive di questo documento. Non meno importante, è stata eseguita tutta l'installazione, configurazione su misura e hardening.

\section{Architettura realizzata}
L'architettura finale che è stata realizzata, e che verrà dettagliata di seguito, si compone come in figura \ref{fig:cuckoo_vms_architecture}.
Sono presenti diverse macchine virtuali:
\begin{itemize}
    \item \emph{Cuckoo Ubuntu VM} è l'Host, ossia dove risiede la sandbox e tutti i Guest. Espone, tramite un'interfaccia di rete locale di VirtualBox denominata \emph{cuckoo-net}, una REST API dov'è possibile inviare sample da analizzare all'orchestrator e successivamente ricevere informazioni sullo stato del task, incluso il suo report, quando pronto per essere scaricato
    \item \emph{API Client VM} è una macchina virtuale isolata dal resto del sistema che ha il compito di interagire con l'Orchestrator, inviando task e ricevendo le risposte. Fornisce un'interfaccia utente da linea di comando per l'interazione e leggerà, per comodità, i file da analizzare da un volume montato in sola lettura
    \item \emph{Windows 7 Nested VM} rappresenta uno dei due Guest identici creati all'interno della Cuckoo VM, e si tratta di macchine virtuali VirtualBox innestate, con installato e configurato Windows 7 e tutti i programmi tradizionali, come ci si aspetterebbe di trovare un reale PC; di questo e altri accorgimenti per rendere la simulazione più fedele possibile ne verrà discusso nella sezione \ref{chap:dynamic-anti-vm-detection}
\end{itemize}

L'uso di una VM che al suo interno ne contiene altre 2 o più innestate, anziché installare tutto direttamente sul server o computer vero e proprio, vede le sue ragioni nel voler aumentare il più possibile l'isolamento tra il sistema di sandbox e il computer dove ciò viene eseguito, nonché rendere il sistema nella sua interezza più portabile. Sarà necessario esportare le 2 macchine virtuali più esterne e creare le interfacce di rete per poter eseguire questo sistema altrove con la minima configurazione necessaria. L'unico requisito che viene aggiunto è il supporto alla virtualizzazione innestate (e non solo la virtualizzazione tradizionale) sul server fisico che eseguirà il progetto.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{assets/cuckoo_vms.png}
    \caption{Architettura dell'infrastruttura di analisi dinamica}
    \label{fig:cuckoo_vms_architecture}
\end{figure}

\subsection{Installazione e configurazione}
\label{chap:cuckoo-installation-configuration-services}
Una volta delineato lo schema di ciò che si vuole ottenere e il software alla base da cui partire, il primo passo è la sua installazione e configurazione. Non trattandosi di un normale software ma di una serie di componenti complessi da integrare, fin da subito la stessa installazione della sandbox si è dimostrata articolata.

Viene creata la macchina virtuale Cuckoo VM che, siccome conterrà al suo interno sia componenti complessi che altre macchine virtuali, deve avere allocate ingenti risorse. Si è scelto di riservare 8 core CPU e 8GB di RAM a tale scopo, con inizialmente solo 2 istanze delle VM innestate Windows 7. In caso si voglia scalare questo sistema su un server più potente, basterà solamente modificare le risorse allocate nella configurazione di VirtualBox in maniera semplice.

Il primo problema riscontrato è che, data la storicità di Cuckoo, è sviluppato in Python 2, mentre nelle più recenti versioni di Ubuntu la versione di Python di default è la 3, notoriamente non retrocompatibile.
Viene così installato Python 2 manualmente, poi creato un virtual environment (\texttt{virtualenv}) per isolare le dipendenze del progetto dai pacchetti Python installati globalmente nel sistema e rendere il comando \texttt{python} di default un alias della versione 2, quando questo ambiente virtuale è attivato.
Un virtualenv Python è definito dalla Python Enhancement Proposals PEP-405
\footnote{\url{https://peps.python.org/pep-0405/}}
e fornisce gli strumenti per creare ambienti isolati tra loro, aventi ognuno le proprie dipendenze, versione dell'interprete e altre caratteristiche per non rompere il resto del sistema o progetti tra loro incompatibili, come in questo caso.
Per impostare l'uso di una versione diversa da quella di default, si è usato il comando \texttt{virtualenv --python="\$(which python2.7)" VENV\_PATH/.venv}; l'attivazione si realizza con l'esecuzione di \texttt{source .venv/bin/activate} mentre ci si trova all'interno della directory del progetto.

Successivamente alle dipendenze Python, è stato richiesto di installare anche tutta una serie di servizi esterni.
Il primo è chiaramente VirtualBox internamente alla VM stessa, per procedere con la virtualizzazione innestata.
Poi sono venuti tutti i servizi necessari per il funzionamento dell'Orchestrator di Cuckoo, come il database PostgreSQL, MongoDB per la cache ed ElasticSearch per la correlazione dei dati. La scelta migliore per questi è stata la realizzazione di un file \texttt{docker-compose.yml} con tutti i servizi necessari e loro configurazioni (come variabili d'ambiente, mount di file o bind di porte di rete sull'interfaccia di loopback), installando perciò solo Docker e Docker Compose nel sistema, per avere massima compatibilità e minori problemi di setup.

Una volta che tutti i servizi accessori sono pronti per essere utilizzati, e dopo aver aggiornato i file di configurazione di Cuckoo per permetterne la raggiungibilità (impostando le variabili d'ambiente, le porte da contattare, etc), vanno attivati i servizi di Web interface e REST API.
La prima ci servirà solamente in locale sulla VM stessa, non esposta all'esterno, a fini di debug e per un utilizzo iniziale più semplice. La seconda, al contrario, andrà esposta sulla rete interna \emph{cuckoo-net} per permettere alla VM \emph{API Client} di interagirvi. In questa fase di setup iniziale, viene tutto esposto su ogni interfaccia (bind su \texttt{0.0.0.0}) per facilitarne il debug, poi perfezionato durante l'Hardening (sez. \ref{chap:dynamic-vm-hardening}).

\subsection{Creazione delle VM Windows}
Per quanto concerne le VM innestate con Windows, si è scelto di adoperare la versione 7 del sistema operativo. Questa è ancora molto diffusa, soprattutto in ambito enterprise dove eventuali malware creerebbero maggiori danni, è supportata da Cuckoo allo stato attuale e, infine, ha opzioni per disattivare il maggior numero di funzionalità di sicurezza di Windows, quindi analizzare a pieno tutti i comportamenti che desidererà compiere il malware nell'ambiente di sandbox.

La creazione di una o più istanze del Guest è stata eseguita con \texttt{vmcloak}.
Questo strumento si interfaccia con VirtualBox e consente la creazione di VM in maniera automatizzata e replicabile.

Viene assegnata una quantità di risorse paragonabile a un computer di fascia bassa verosimile. Il disco sarà di 128GB, allocato dinamicamente, con 4 core CPU e 2GB di RAM. Consentità un'esecuzione non eccessivamente limitante, senza sprecare troppe risorse, specialmente se si prevede di aumentare la parallelizzazione, come spiegato nella sez. \ref{chap:dynamic-vm-replication}.

Vengono poi installati al loro interno tutta una serie di strumenti di utilità che ci si aspetterebbe di trovare in un normale PC aziendale o personale. Questa caratteristica potrebbe sembrare superflua ma in realtà gioca un ruolo molto importante (assieme alle più avanzate tecniche che vedremo nella sezione \ref{chap:dynamic-anti-vm-detection}):
\begin{itemize}
    \item Serve come prima tecnica superficiale di anti-VM-detection, per cui un malware potrebbe rilevare se ci si trova in un ambiente di test o meno in base alla presenza o assenza di software che la quasi totalità degli utenti reali avrebbe sul proprio computer
    \item Ampia la superficie di attacco possibile sulla macchina Windows, in caso un malware non esegua direttamente il codice che genera danni nel sistema target ma, in maniera più subdola, vada a sfruttare falle di sicurezza presenti in altri programmi che comunemente un utente avrebbe
    \item Permette l'analisi di file diversi, come DOCX con macro non desiderate o PDF con payload eseguibili
\end{itemize}

Gli specifici software installati e operazioni effettuate sono:
\begin{itemize}
    \item Adobe PDF Reader
    \item DotNet, Java, Flash e Visual C++ Redistributable 2015: per eseguire programmi che richiedono queste runtime
    \item Internet Explorer 11, Google Chrome e Firefox
    \item Modifica dello sfondo da quello di default a uno random
    \item WinRAR
    \item Windows 7 Service Pack 1
    \item Risoluzione dello schermo fissata a 1280x1024
    \item Suite Office
\end{itemize}

Chiaramente, è stata rigorosamente proibita l'installazione delle VirtualBox Guest Additions, che hanno lo scopo di integrare meglio la VM e fornire più servizi, ossia il contrario dell'obiettivo prefissato.

\subsection{Anti-VM detection}
\label{chap:dynamic-anti-vm-detection}
Alcuni malware, per rendere più difficoltosa l'analisi in ambienti controllati, quindi rallentare lo sviluppo di un rilevamento accurato e una conseguente mitigazione, adottano tecniche di VM-detection. Se capiscono di essere sotto analisi, non eseguono affatto il comportamento che svolgerebbero su un ambiente reale, sia non compiendo azioni o compiendone di normali. Un esempio può essere un Trojan che, se sotto analisi, eseguirà regolarmente il programma autentico per cui si camuffa, compromettendo il sistema solo in ambienti reali.

Data la numerosità di queste tecniche, si è reso necessario trovare una PoC che possa eseguirle in maggior numero possibile e restituire un report su quali rilevazioni continuano a dare esito positivo. \emph{Pafish64} è un progetto open source, rilasciato sotto licenza GPLv3 e disponibile su GitHub
\footnote{\url{https://github.com/a0rtega/pafish}},
che ha come scopo proprio ciò di cui necessitiamo in questo stadio.
Procediamo ad eseguire il test sulle VM realizzate, senza ancora aver adottato alcuna strategia di mitigazione, per individuare dove e come operare. Il risultato, riportato in figura \ref{fig:pafish_standard_vm}, è pessimo: un gran numero di test falliscono, tra cui:
\begin{enumerate}
    \item tutti quelli che verificano la presenza di un potenziale essere umano,
    visualizzando un dialog con un tasto OK e aspettando che qualcuno lo vada a premere
    \item la rilevazione dell'hypervisor VirtualBox che si sta utilizzando
    \item alcuni controlli su aspetti più specifici della CPU
\end{enumerate}

Come prima strategia, si vanno ad installare nelle VM le DLL fornite da Cuckoo per fare l'hooking delle chiamate di sistema che un processo eseguirà per tali rilevamenti, come nascondere alcuni registri di sistema intercettando le syscall \texttt{RegOpenKeyEx}, o eseguire OCR sullo schermo e muovere il mouse di conseguenza, compiendo azioni banali che un utente eseguirebbe con alta probabilità.
Appena impostata la DLL injection, viene ripetuto il test. Il risultato è in figura \ref{fig:pafish_cuckoo} e presenta molti meno risultati negativi.
Tuttavia, non si potrà progredire ulteriormente a causa dell'attuale architettura impostata e della ben maggiore difficoltà che avrebbe la realizzazione di soluzioni di mitigazione più sofisticate, al di fuori dello scopo del progetto qui realizzato.
Infatti, a titolo esemplificativo, notiamo come l'hypervisor ottenuto leggendo i valori forniti dalla CPU (virtuale) sia \emph{VBoxVBoxVBox}, riconducibile a VirtualBox; questo accade perché valori del genere vengono letti dalla macchina su cui la VM Windows 7 esegue, ma nella configurazione realizzata si tratta a sua volta di VirtualBox, per cui la strategia risulta inefficace.

Ci si ritiene però altamente soddisfatti del risultato poiché sono pochissimi i test che falliscono, abbassando la probabilità che un malware da analizzare utilizzi proprio quelli. Non può usarne in gran numero poiché sono rilevabili dalla sanbox tra le syscall eseguite, quindi riportate all'analista che può subito dedurre se si tratti di un comportamento lecito o inaspettato.

\begin{figure}[htbp]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{assets/pafish_standard_vm_1.png}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{assets/pafish_standard_vm_2.png}
\end{subfigure}
\caption{Pafish eseguito in una classica VM Windows 7}
\label{fig:pafish_standard_vm}
\end{figure}

\begin{figure}[htbp]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{assets/pafish_cuckoo_1.png}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{assets/pafish_cuckoo_2.png}
\end{subfigure}
\caption{Pafish eseguito sotto l'analisi di Cuckoo Sandbox}
\label{fig:pafish_cuckoo}
\end{figure}

\subsection{Replicazione VM}
\label{chap:dynamic-vm-replication}
Una volta realizzata una istanza della VM Windows 7, per migliorare la scalabilità del sistema,
quindi permettere che più task possano eseguire in parallelo, 
si devono creare più istanze replicate della stessa.

Per deduplicare la base comune a tutte le istanze, come il sistema operativo e i tool installati, si trasforma il disco virtuale da standard a multi-attach, così da essere connesso a più VM in contemporanea.

A livello di rete si assegna un IP statico a ogni VM, consentendo a Cuckoo di correlare il traffico verso e da un determinato IP locale, a una specifica VM, quindi a uno specifico task di analisi in corso in un determinato istante di tempo.
Per permettere il forwarding dei pacchetti attraverso questa interfaccia, viene configurata usando il seguente comando a livello di orchestrator:
\begin{minted}{shell}
sudo sysctl -w net.ipv4.conf.vboxnet0.forwarding=1
sudo sysctl -w net.ipv4.conf.enp0s3.forwarding=1
\end{minted}

Infine, si creano le istanze con vmcloak e si eseguono gli snapshot: questi verranno ripristinati subito dopo l'esecuzione di un task di analisi, così da ripartire sempre con lo stesso sistema pulito iniziale e non rischiare che un malware, dopo che infetti la VM, vada a mantenere il controllo della macchina virtuale anche successivamente.

\subsection{Servizi systemd}
Si nota come al boot, tutti i servizi che precedentemente erano funzionanti, debbano essere eseguiti manualmente. Questo passaggio è totalmente da rimuovere per una corretta automazione del processo, e la soluzione migliore in ambito Linux per eseguire servizi al boot è la creazione di \emph{unit di systemd}. Systemd è un sistema di init e gestione dei servizi, ampiamente diffuso nella quasi totalità delle distribuzioni Linux, che deve eseguire con PID 1 (PID 0 è il processo scheduler, parte del kernel) per il corretto funzionamento. I servizi che deve avviare sono descritti attraverso dei file posti in \texttt{/etc/systemd/system/} chiamati \textbf{unit}.
Come caratteristiche fondamentali, una unit conterrà:
\begin{itemize}
    \item Un nome, dato dal file stesso, e una descrizione per permetterne il riconoscimento in futuro
    \item Uno o più servizi o target da cui dipende, che devono essere avviati prima di esso
    \item L'utente con il quale eseguire
    \item Il comando da lanciare per avviare ed interrompere il servizio
    \item Politiche di restart, che imposteremo ad \emph{always}
    poiché necessitiamo che i vari componenti vengano riavviati automaticamente se dovessero smettere di funzionare
\end{itemize}

Vengono così create le seguenti unit:
\begin{itemize}
    \item \texttt{vboxnet0.service} contiene il comando per creare e avviare preventivamente l'interfaccia di rete
    che useranno Cuckoo e le VM Guest per dialogare e far transitare il traffico di rete da sniffare
    \item \texttt{cuckoo-docker.service} avvia tutti i servizi accessori che Cuckoo
    necessita per il funzionamento, come i database, menzionati in \ref{chap:cuckoo-installation-configuration-services},
    tramite un file Docker Compose
    \item \texttt{cuckoo.service}, che avvierà il demone di Cuckoo una volta che le dipendenze saranno pronte all'uso
    \item \texttt{cuckoo-api.service}, responsabile del server di REST API usato poi dal client esterno a questa VM
    \item \texttt{cuckoo-web.service} risulta utile quando, in fase di testing, si vuole usare una comoda UI per capire il funzionamento
\end{itemize}

\begin{code}
\begin{minted}{INI}
[Unit]
Description=Cuckoo Web Service
Requires=cuckoo.service
After=cuckoo.service

[Service]
User=cuckoo
RemainAfterExit=yes
ExecStart=/home/cuckoo/cuckoo/bin/cuckoo web -H 127.0.0.1 -p 8000
TimeoutStartSec=0
Restart=always

[Install]
WantedBy=multi-user.target
\end{minted}
\label{lst:systemd-unit-example}
\caption{Esempio di systemd unit per il servizio Web}
\end{code}
\bigskip

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[node distance=1.5cm, xscale=2]
  % Nodes
  \node (cuckoo) [ellipse, draw] {cuckoo};
  \node (vbox) [ellipse, draw, below left= of cuckoo] {vboxnet0};
  \node (docker) [ellipse, draw, above left= of cuckoo] {cuckoo-docker};
  \node (api) [ellipse, draw, below right= of cuckoo] {cuckoo-api};
  \node (web) [ellipse, draw, above right= of cuckoo] {cuckoo-web};

  % Edges
  \draw[->] (vbox) -- (cuckoo);
  \draw[->] (docker) -- (cuckoo);
  \draw[->] (cuckoo) -- (api);
  \draw[->] (cuckoo) -- (web);
\end{tikzpicture}
\caption{Grafo delle dipendenze dei servizi systemd aggiunti}
\label{fig:systemd-cuckoo-dependency-graph}
\end{figure}

\section{VM Client con CLI}
\label{sez:dynamic-python-client-vm}
Seguendo l'architettura desiderata in figura \ref{fig:cuckoo_vms_architecture},
si procede alla realizzazione della API Client VM.
Questa deve rispettare una serie di caratteristiche, come l'isolamento e la leggerezza, non contenendo particolari software.

Dovrà includere un programma client, scritto in Python, realizzato da zero per il progetto, utile sia come vero e proprio client che come Proof-of-Concept per una futura integrazione con le API della Threat Intelligence. Questo, infatti, interagisce direttamente con le REST API esposte da Cuckoo, esegue il parsing dei risultati e la modellazione delle chiamate in distinti metodi di una classe per astrarne l'implementazione.
Essendo già così suddiviso, rende possibile la scrittura di un altro programma Python per essere usato in un diverso ambiente, riciclando il codice relativo alle chiamate REST. Ciò porta a un risparmio di risorse umane per futuri sviluppi e alla minor probabilità di introdurre bug, riutilizzando codice già testato in precedenza.

Il Client può essere usato come libreria o essere eseguito direttamente da terminale come modulo (\texttt{python3 -m cuckoo-api-client ARGS...}), passando diverse possibili opzioni, tra cui l'analisi di un file o di un'intera cartella, e l'impostazione di un path dove andare a salvare tutti gli output.
Questi ultimi consistono nel report JSON elaborato, nonché gli screenshot dell'esecuzione e il file pcap con la cattura dei pacchetti di rete.
Per agevolarne l'usabilità, fornisce messaggi di errore e di help tramite l'ausilio del modulo \texttt{argparse}, e durante l'esecuzione mostra output colorato e in costante aggiornamento sullo stato dei task, che siano in coda, terminati o pendenti.

La VM ne conterrà una copia già al suo interno, così da ridurre dipendenze esterne o necessità di mount di cartelle dall'host fisico. Per la massima leggerezza, è basata su Arch Linux con installate solo le dipendenze strettamente necessarie per il funzionamento, e XFCE come Desktop Environment minimale per la visualizzazione di screenshot o altri file che possono essere più comodamente aperti utilizzando programmi con una GUI. Grazie a questa scelta, è stato possibile mantenere la dimensione della macchina virtuale, esportata come file OVA, inferiore a 3GB.

Avrà un indirizzo IP statico per facilitarne la raggiungibilità e sarà connessa all'interfaccia di rete interna \emph{"cuckoo-net"}, come descritto nell'architettura.

\subsection{Nuovo formato del report}
\label{sez:dynamic-report-new-format}
Dopo una prima osservazione del report originale, così come elaborato da Cuckoo, ci si è resi conto della sua bassa consultabilità, risultando eccessivamente lungo e dispersivo. Inoltre, alcune voci non sono ben organizzate, come le syscall intercettate che non presentano una chiara distinzione tra i vari thread del processo ma sono elencate tutte assieme. Questo comporta che, in caso di due o più thread che eseguono operazioni distinte, non è facile ricostruire il flusso logico semplicemente leggendo questo elenco, poiché i vari flussi sarebbero uniti.
Per questa e altre ragioni di comodità da parte dell'analista, oltre a motivazioni più tecniche dovute alla struttura del JSON con cui generalmente lavora la Threat Intelligence, si è optato per eseguire una trasformazione lato client.

Per prima cosa, viene studiata la struttura del JSON fornito da Cuckoo per capire come e dove intervenire. Nel primo livello, si tratta di un oggetto (e non una lista), con diverse chiavi. 
Questa caratteristica risulta utile: restituire come dato un oggetto rende successivi aggiornamenti o aggiunte alla struttura dati molto più agevole, rispetto a una lista o altre strutture più basilari.
Le prime chiavi che sono ben strutturate e andremo a ricopiare nel report trasformato sono i metadati (\texttt{target} e \texttt{task\_info}), i dati sugli screenshot e le stringhe individuate nel file.
Le sezioni dov'è richiesto il maggior intervento per organizzare meglio, secondo le esigenze, sono quella relativa ai processi e syscall, e l'area di network con le analisi del traffico di rete.

Le informazioni sui processi vengono fornite in maniera estremamente ridondante e dispersiva: vengono elencati tutti i processi, senza una struttura ad albero, e le syscall relative non sono organizzate nei vari thread, infine sono ripetute varie volte in diverse sottosezioni.
Il nuovo report conterrà la seguente struttura:
\begin{itemize}
    \item Una foresta dei processi, dove ognuno ha i propri figli direttamente nella struttura JSON: si parla di foresta e non di albero perché, nel sottoinsieme dei processi analizzati, possono esistere più radici, quindi più alberi distinti tra loro
    \item Per ogni processo, è identificato il PID, il path da cui è stato lanciato, i match con YARA rules identificati, assieme a tutta una serie di statistiche sul numero di syscall eseguite per categoria - come \emph{storage} o \emph{network}
    \item Un processo a sua volta avrà un insieme di thread, ciascuno col proprio elenco di syscall, ordinate cronologicamente per istanze di invocazione
    \item Ogni chiamata a sistema conterrà informazioni quali il nome mnemonico, la categoria, i parametri in input e il valore restituito in output
\end{itemize}

La sezione riguardante il traffico di rete, vede una divisione (prima non presente) tra le categorie di traffico e protocollo usato, come HTTP, HTTPS, TCP con protocollo applicazione custom, SMTP per invio di mail, richieste DNS, UDP o altri protocolli supportati. La divisione, inoltre, serve a far ignorare all'analista tutto ciò che non è rilevante, focalizzandosi su elementi anomali, come una calcolatrice che invia traffico SMTP verso un server con IP non conosciuto.
Per tutti i protocolli, sono riportati gli indirizzi IP sorgente e destinazione, da cui possiamo dedurre sia l'interlocutore che la direzione della comunicazione, così come le porte coinvolte e il timestamp di esecuzione.
Protocolli di livello applicazione, come HTTP, contengono informazioni già elaborate.
Proprio in questo caso d'esempio, viene restituita una struttura dati ad oggetto dove sono già presenti in maniera ordinata i vari header, lo status code e il body di richiesta (se presente) o risposta.
Se possibile, vengono decrittate le comunicazioni TLS, sia con metodologie MITM (man-in-the-middle, sconsigliato e rilevabile dal processo con tecniche quali il Certificate Pinning) che leggendo dai buffer che vengono inviati alle syscall durante queste operazioni, a patto che non abbia linking statico alle librerie OpenSSL e simili, ma usi le syscall fornite dal sistema operativo e poi intercettate da Cuckoo Sandbox.

Una caratteristica che va tenuta a mente quando si analizzano i risultati della parte di networking è che si basano principalmente sul traffico catturato ascoltando l'interfaccia di rete. Come conseguenza di ciò, emerge come nel risultato siano presenti anche pacchetti che il processo sotto analisi non ha mai inviato o ricevuto, ma attribuibili ad altri processi all'interno del sistema, come software di Microsoft che eseguono operazioni di routine (ricerca di update del sistema operativo, etc...).
Da un lato può essere visto come un punto a favore, così che se per qualche vulnerabilità di programmi di sistema, venisse effettuato traffico di rete malevolo partendo proprio da questi, sarebbe comunque rilevato e analizzato dall'analista. In maniera speculare però è un punto a sfavore l'aver il risultato dell'analisi meno pulito e con elementi superflui.
Si è scelto, allo stato attuale, di rimandare tale decisione all'analista e al sistema di Threat Intelligence poi, ad esempio eseguendo una analisi di un programma mockup che non esegua alcuna operazione di rete, per estrarre così il traffico che ci possiamo aspettare da altre future analisi. Ai fini del progetto, vengono conservati tutti i pacchetti.

\newpage
\begin{code}
\begin{minted}[samepage]{json}
{
  "process_forest": [{
      "pid": 1548,
      "is_root": true,
      "children": [{
          "pid": 2128,
          "is_root": false,
          "children": []
        }]
    }],
  "processes": {
    "2128": {
      "process_name": "win-http.exe",
      "summary": {
        "connects_ip": ["93.184.216.34"],
        "resolves_host": ["example.com"]
      },
      "signatures": [],
      "apistats": {
        "getaddrinfo": 1,
        "socket": 1
      },
      "modules": [{
          "baseaddr": "0x77110000",
          "filepath": "C:\\Windows\\SYSTEM32\\ntdll.dll"
      }],
      "main_thread_id": 884,
      "thread_calls": {
        "884": [{
            "category": "network",
            "status": 1,
            "api": "socket",
            "return_value": 96,
            "arguments": {
              "protocol": 0,
              "socket": 96,
              "af": 2,
              "type": 1
            },
            "tid": 884
        }]
      }
}}}
\end{minted}
\caption{Esempio di output per le informazioni sui processi, sintetizzato}
\end{code}

\begin{code}
\begin{minted}{json}
{
  "network": {
    "tls": [],
    "udp": [
      {
        "src": "192.168.56.101",
        "dst": "20.101.57.9",
        "offset": 515017,
        "time": 6.215277194976807,
        "dport": 123,
        "sport": 123
      }
    ],
    "dns_servers": [
      "8.8.8.8"
    ],
    "icmp": [],
    "tcp": [
      {
        "src": "192.168.56.101",
        "dst": "51.132.193.105",
        "offset": 522251,
        "time": 11.470929145812988,
        "dport": 443,
        "sport": 49165
      }
    ],
    "dns": [
      {
        "type": "A",
        "request": "example.com",
        "answers": [
          {
            "data": "93.184.216.34",
            "type": "A"
          }
        ]
      }
    ],
    "http": [
      {
        "status": 304,
        "src": "192.168.56.101",
        "protocol": "http",
        "dst": "93.184.221.240",
        "uri": "/msdownload/update/v3/static/trustedr/en/authrootstl.cab",
        "host": "www.download.windowsupdate.com",
        "dport": 80,
        "sport": 49191,
        "method": "GET",
        "request": {
          "headers": "Connection: Keep-Alive\r\nAccept: */*",
          "content_sha1": "da39a3ee5e6b4b0d3255bfef95601890afd80709"
        },
        "response": {
          "headers": "HTTP/1.1 304 Not Modified\r\nAccept-Ranges: bytes",
          "content_sha1": "da39a3ee5e6b4b0d3255bfef95601890afd80709"
        }
      },
      {
        "status": 200,
        "src": "192.168.56.101",
        "protocol": "http",
        "dst": "93.184.216.34",
        "uri": "/",
        "host": "example.com",
        "dport": 80,
        "sport": 49171,
        "method": "GET",
        "request": {
          "headers": "GET / HTTP/1.1\r\nHost: example.com\r\nConnection: close",
          "content_sha1": "da39a3ee5e6b4b0d3255bfef95601890afd80709"
        },
        "response": {
          "headers": "HTTP/1.1 200 OK\r\nCache-Control: max-age=604800",
          "content_sha1": "4a3ce8ee11e091dd7923f4d8c6e5b5e41ec7c047"
        }
      }
    ]
  }
}
\end{minted}
\caption{Risultato trasformato per la parte di networking, inclusi i pacchetti provenienti da altri processi}
\end{code}
\newpage

\section{Hardening}
\label{chap:dynamic-vm-hardening}
Un sistema di sandbox è molto delicato e deve essere protetto adeguatamente.
La VM dove eseguono Cuckoo e i guest innestati rappresentano il punto critico, dato che una loro errata configurazione potrebbe aprire le porte all'attaccante verso l'intero sistema host ed evadere così dalla sandbox.
Adotteremo il principio del minimo privilegio (Principle of Least Privilege - PoLP).

A livello di rete, si è notato come un processo interno alla sandbox (Windows 7) possa riuscire a contattare con successo altri dispositivi nella LAN del sistema host fisico. Questo deve essere chiaramente proibito, poiché un malware potrebbe scoprire e attaccare altri dispositivi vulnerabili nella propria rete domestica o aziendale.
Per far ciò, vengono impostate delle regole precise di IPTables. Useremo il programma \texttt{ufw} per applicare le regole, dato che sotto la scocca usa comunque IPTables ma con un'interfaccia per l'utente molto più intuitiva e meno error-prone, restando pur sempre su CLI.
Blocchiamo, dalla VM cuckoo più esterna, tutto il traffico verso l'host (interfaccia \texttt{enp0s3}) che sia indirizzato a classi di IP privati. Nell'esempio di seguito, applichiamo la regola per proibire di raggiungere tutti i dispositivi in una rete con indirizzi privati di classe C; verrà replicato per tutte le altre classi di indirizzi da bloccare.

\begin{minted}{shell}
sudo ufw deny out on enp0s3 to 192.168.0.0/16
sudo ufw enable && sudo ufw reload
\end{minted}

Per quanto riguarda il gateway, dobbiamo consentire il traffico che transita verso di esso, ma non direttamente a lui destinato. La regola è applicabile con il seguente comando di ufw, dove \texttt{10.0.2.2} è l'indirizzo IP del gateway, concretizzato nell'host fisico dove gira VirtualBox:

\begin{minted}{shell}
sudo ufw deny out on enp0s3 to 10.0.2.2
\end{minted}

La comunicazione tra la VM di analisi e la VM client, che transita sull'interfaccia di rete interna di VirtualBox denominata \texttt{cuckoo-net}, poi assegnata al sistema con nome \texttt{enp0s8}, deve essere controllata.
Ricordando che le due macchine hanno assegnati i propri IP statici, dobbiamo limitare il traffico facendo sì che solo la VM client sia in grado di aprire una connessione verso l'analizzatore, limitatamente alla porta 8080. Oltre a limitare sul client tutte le connessioni in ingresso a livello di firewall, anche se esista una porta aperta con bind su 0.0.0.0 (tutte le interfacce), va applicata la seguente regola sull'analizzatore, tenendo \texttt{deny} come azione di default per il traffico in ingresso:
\begin{minted}{shell}
sudo ufw allow in \
    on enp0s8 \
    to 192.168.50.11 \
    port 8080 proto tcp \
    from 192.168.50.12
\end{minted}
questa permette comunicazioni solo sulla porta 8080 dove è in ascolto il server REST API di Cuckoo, tramite una connessione TCP, dall'interfaccia di rete condivisa e isolata tra le due macchine, unicamente dall'indirizzo IP statico a lei assegnato.

Oltre alla rete, si vuole proteggere anche tutto l'ambiente di esecuzione interno all'analizzatore, quindi si è creato un utente Unix distinto, denominato \texttt{cuckoo}, da cui lanciamo VirtualBox e non dispone di alcun permesso, tantomeno è nel gruppo sudo (i cosiddetti \emph{sudoers}). La sua password è bloccata e la shell è impostata a \texttt{/usr/bin/nologin} così da inibirne completamente l'accesso.
Per l'avvio però è presente un utente \texttt{pc} che può eseguire il programma di VirtualBox e aprire una shell impersonando l'utente meno privilegiato utilizzando sudo:
\begin{minted}{shell}
xhost +SI:localuser:cuckoo
sudo -u cuckoo virtualbox
\end{minted}
Il comando di \texttt{xhost} si è reso necessario per far sì che anche la GUI del programma possa essere correttamente visualizzata. XHost è una utility del server grafico X, e con questo comando si autorizza l'utente meno privilegiato a contattarlo per mostrare finestre o altri elementi visivi nella sessione dell'utente corrente.

\section{Plugin aggiuntivi}
Si è optato per estendere la sandbox, integrando altri software più innovativi e fornire una metodologia standard per un'integrazione di ulteriori strumenti in futuro.
I tool in questione richiesti sono:
\begin{itemize}
    \item \textbf{Patriot},
    \footnote{\url{https://github.com/joe-desimone/patriot}}
    piccolo progetto di ricerca per identificare tecniche di occultamento in memoria (\emph{in-memory stealth}) usando in maniera non standard alcune chiamate di sistema di Windows
    \item \textbf{Hunt-Sleeping-Beacons},
    \footnote{\url{https://github.com/thefLink/Hunt-Sleeping-Beacons}}
    che ha lo scopo di identificare i beacons decompressi a runtime, o in esecuzione nel contesto di altri processi; si tratta di agenti C\&C (Command and Control) e si osservano beacon che attendono tra loro, andando in sleep e causando ritardo nell'esecuzione, evitando di essere intercettati in una normale analisi tradizionale
\end{itemize}

Approfondendo quest'ultimo strumento, le tecniche di sleep obfuscation che va a rilevare includono casistiche come \emph{DelayExecution}, in cui un processo agent C2 andrà a richiamare \texttt{Kernel32!Sleep}, che però indirettamente invoca \texttt{Ntdll!NtDelayExecution}, portando il processo in stato di waiting;
ma anche tecniche più avanzate come \emph{Foliage}, che usano una serie di syscall per ritardare l'esecuzione senza tuttavia transitare per lo stato di DelayExecution, risultando molto meno rilevabili in modi convenzionali, fino a rilevare \emph{Ekko} o implementazioni analoghe ancora più sofisticate.

\subsection{Download durante l'analisi}
Entrambi questi tool vengono forniti dai rispettivi autori come eseguibili precompilati o facilmente compilabili dai sorgenti pubblici con MinGW.
Questi devono tuttavia essere eseguiti durante l'analisi all'interno della VM guest Windows 7. Per fare ciò, non è stato identificato alcun metodo già fornito da Cuckoo Sandbox, allora è stato realizzato un piccolo server HTTP in Python che, eseguendo sulla VM Ubuntu ed esposto su una porta definita (50001) limitatamente all'interfaccia di rete nominata \emph{enp0s8} condivisa tra le 2 VM VirtualBox.

Per ridurre la superficie di attacco, non si va ad usare il modulo \texttt{http.server} già presente nella libreria standard poiché potrebbe essere vulnerabile ad attacchi Path Traversal o analoghi.
Come soluzione adottata, si crea un semplice server HTTP che accetta solo richieste GET e, a seconda dell'endpoint, viene scelto il percorso del file da una serie di stringhe hardcoded, così da rendere impossibile Path Traversal in quanto l'input utente non è mai utilizzato per accedere al file, ma viene solo confrontato con una serie di stringhe.

Al contrario, la comunicazione nella direzione inversa, quindi dal guest all'host, è gestita tramite la API di Cuckoo attraverso la funzione \texttt{upload\_to\_host}, dove si può passare il path di un file da copiare e successivamente da esaminare.

\subsection{Esecuzione come plugin Cuckoo}
Successivamente all'installazione dei tool nell'ambiente di sandbox, è necessario eseguirli e integrarli all'interno del flusso di analisi di Cuckoo.
Questo è possibile grazie all'implementazione di plugin in Python 2 usando le API della sandbox.

Si compone di due distinte componenti, entrambe da realizzare in Python 2:
\begin{itemize}
    \item modulo \textbf{Auxiliary}: esegue nella VM Guest e al termine deve riportare i dati ottenuti alla VM Host per l'analisi
    \item modulo \textbf{Processing}: esegue nella VM Host e riceve i dati di output forniti dall'auxiliary
\end{itemize}

Partendo dai moduli auxiliary, molto simili tra loro, lo scopo è scaricare ed eseguire il programma corrispondente del modulo, ripeterlo in loop per collezionare il maggior numero possibile di match, infine organizzare i report eliminando i duplicati e riportarlo all'host.
Questo tipo di moduli è concretizzato in un file Python con una classe custom che estende la classe astratta \texttt{Auxiliary} e implementa i metodi \texttt{start} con cui avviare l'esecuzione e segnala che è il file da analizzare sta per essere avviato, così da dare modo al plugin di predisporre tutti gli strumenti necessari, che siano tool, hook, capture di rete, o altro; e il metodo \texttt{stop} necessario per interrompere e ripulire l'ambiente d'esecuzione.
Inoltre, siccome il loop di esecuzione continua del tool deve essere non bloccante, altrimenti l'intero flusso di esecuzione dell'agent di Cuckoo viene bloccato, senza di fatto eseguire mai, deve essere delegato in un thread in background.
Sarà presente un flag che, impostato inizialmente a True prima dell'esecuzione, verrà settato a False durante lo stop del modulo, così da interrompere il thread con una graceful exit.
Lo standard output (stdout) è conservato dentro un file di log, poi inviato al modulo di Reporting.

\subsection{Parsing dei risultati}
La parte di analisi del log raccolto è svolta nei moduli di Reporting che, come annunciato, sono eseguiti all'interno della VM host da parte dell'orchestrator.
Sono delle classi che estendono la classe astratta \texttt{Reporting} e devono implementare il metodo \texttt{run()} che restituirà al chiamante la struttura da inserire nel report finale.

Ricevono i dati caricati dall'auxiliary e verranno trasformati in apposite strutture, codificate in formato JSON, restituite nel report finale complessivo poi inviato al client che ha richiesto l'analisi.
Il modo in cui vengono interpretati i risultati è fortemente dipendente dal tool e dal suo output specifico, per cui in questo caso i moduli mostreranno sostanziali differenze date dalla natura dello strumento stesso.
Di seguito ne analizziamo il comportamento.

\subsubsection{Patriot}
L'output testuale è dato in input al parser nel formato mostrato in figura \ref{fig:dynamic-patriot-output-text}.
Si evince facilmente come i dati di nostro interesse siano già mostrati come chiave-valore, dove le chiavi sono gli elementi \texttt{Level}, \texttt{Type}, \texttt{Detail}, \texttt{PID} e \texttt{Process}.
Sarà sufficiente notare come le varie sezioni sono divise da una serie di trattini e una linea vuota, ossia la sequenza di caratteri \texttt{\textbackslash{}n\textbackslash{}n}. Per ogni riga di ogni sezione, basta dividere tra chiave e valore andando a fare uno split della stringa alla prima occorrenza del carattere \texttt{:} e unendo il tutto dentro un dizionario, poi restituito nell'output trasformato.
Possono essere rimossi tutti i duplicati, dovuti all'esecuzione in loop dello strumento, come spiegato nella sezione precedente.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{assets/patriot-example-output.png}
    \caption{Esempio di output testuale di Patriot}
    \label{fig:dynamic-patriot-output-text}
\end{figure}

\begin{code}
\begin{minted}{json}
[
    {
        "Level": "suspect",
        "Type": "peIntegrity",
        "Detail": "Executable region 000007fefd131000 likely modified",
        "PID": 2656,
        "Process": "SDXHelper.exe",
        "Module path": "\\Windows\\System32\\KernelBase.dll",
        "Module base": "7fefd130000"
    },
    {
        "Level": "suspect",
        "Type": "peIntegrity",
        "Detail": "Executable region 000007feff211000 likely modified",
        "PID": 2656,
        "Process": "SDXHelper.exe",
        "Module path": "\\Windows\\System32\\oleaut32.dll",
        "Module base": "7feff210000"
    }
]
\end{minted}
\caption{Esempio di output di Patriot trasformato in JSON dal plugin}
\end{code}

\subsubsection{Hunt-Sleeping-Beacons}
Nel caso specifico di questo strumento, siccome l'output testuale che fornisce è in un formato molto flessibile e può essere espresso in una moltitudine di modi diversi, si è scelto di non trasformarlo in una struttura a dizionario.
Si è ritenuto notevolmente più utile, ai fini della rilevazione, filtrare unicamente le righe inizianti per \texttt{[!]} le quali indicano la motivazione e il target (nome del processo e PID) di una detection.
Le righe così ottenute possono essere filtrate eliminando i duplicati e restituendole in output come una lista.

\begin{code}
\begin{minted}{text}
[!] Suspicious Process: beacon.exe (5296)

   [*] Thread (2968) State: DelayExecution and uses stomped module
   [*] Potentially stomped module: C:\Windows\SYSTEM32\xpsservices.dll

       NtDelayExecution -> C:\Windows\SYSTEM32\ntdll.dll
       SleepEx -> C:\Windows\System32\KERNELBASE.dll
       DllGetClassObject -> C:\Windows\SYSTEM32\xpsservices.dll

   [*] Suspicious Sleep() found
   [*] Sleep Time: 5s
\end{minted}
\label{lst:hunt-sleeping-beacons-example-text}
\caption{Esempio di output per una detection di Hunt Sleeping Beacons}
\end{code}

\section{Workflow analisi dinamica}
Successivamente alla creazione dei singoli elementi, riassumiamo l'intero workflow finale di un processo di analisi dinamica.

In primo luogo, sarà richiesto avviare la VM denominata \emph{Ubuntu-cuckoo} in background, senza necessitare dell'uso della UI o di altre interazioni, se non in caso di debugging. Grazie ai servizi systemd creati, è stato reso automatico l'intero avvio, così da non richiedere alcun intervento manuale.

Stando all'architettura indicata a inizio capitolo in figura \ref{fig:cuckoo_vms_architecture}, i malware samples risiedono nella VM \emph{API client}. Per l'attuale configurazione, vengono salvati o direttamente nella VM o in locale sull'host, in una cartella montata nella macchina virtuale in sola lettura; ricordando i rischi identificati nella sezione relativa all'hardening, si è valutato questo come il miglior compromesso tra sicurezza e comodità d'utilizzo, rispetto ad altre soluzioni come connettere questa VM direttamente ad Internet o all'host via servizi di rete.

Avviate entrambe le macchine virtuali costruite, si va ad interagire con la macchina client avviando un terminale ed eseguendo il programma Python client sviluppato su misura (sez. \ref{sez:dynamic-python-client-vm}).
Prenderà come argomenti il file o la cartella con uno o più sample da analizzare, nonché la cartella dove salvare gli output.
Per ridurre il più possibile l'utilizzo dell'input utente nelle fasi di analisi, si è deciso di salvare l'output in una sottocartella avente per nome l'impronta SHA256 del file, e non il filename originale.
Infatti, in caso di errori in una futura automazione, nell'evenienza di una vulnerabilità del filesystem, usare il nome del file così come ricevuto potrebbe allargare la superficie di attacco della sandbox.
Inoltre, presenta il grande vantaggio di raggruppare nella stessa directory i risultati di più analisi relative allo stesso file, seppur ricevuto con nomi distinti, ad esempio \emph{malware.exe} e \emph{malware (1).exe}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{assets/dynamic-api-client-running.png}
    \caption{Output del client Python durante l'esecuzione dei task}
    \label{fig:dynamic-api-client-running}
\end{figure}

I risultati finali, contenuti in questa cartella, saranno di 3 tipi:
\begin{itemize}
    \item Il report JSON complessivo del behaviour, già trasformato nel nuovo formato descritto nella sez. \ref{sez:dynamic-report-new-format}
    \item Gli screenshot scattati durante l'esecuzione del sample, in caso mostri degli elementi grafici
    \item Il file PCAP di cattura di rete contenenti tutti i pacchetti transitati sull'interfaccia che collega la VM a Internet, tramite l'host fisico che opera da gateway
\end{itemize}

Al fine di distinguere risultati relativi allo stesso sample ma eseguiti in momenti differenti, i file avranno come prefisso il timestamp di avvio del task.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{assets/dynamic-api-results.png}
    \caption{File dei risultati per i vari sample}
    \label{fig:dynamic-api-results}
\end{figure}
